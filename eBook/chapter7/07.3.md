# **类型断言**

类型断言的表示方法是```x.(t)```，其中x是接口类型，t是类型。另外，存储在x中的实际值是t类型，t必须满足x的接口类型！以下段落以及代码示例，将澄清类型断言的这个相对偏心的定义。

类型断言帮助您做两件事。第一件事是检查接口值是否保持特定类型。这样使用时，类型断言返回两个值：基础值和bool值。虽然基础值是您可能想要使用的值，但是布尔值告诉您类型断言是否成功！

类型断言所做的第二件事是允许您使用存储在接口中的具体值或将其分配给新变量。这意味着如果接口中有一个int变量，可以使用类型断言获取该值。

但是，如果类型断言不成功，并且您自己不处理该失败，那么您的程序将惊慌失措。现在学习```assertion.go```程序，将分两部分介绍。第一部分包含以下Go代码：

>```go
> package main
> 
> import (
>     "fmt"
> )
> 
> func main() {
>     var myInt interface{} = 123
>     k, ok := myInt.(int)
>     if ok {
>         fmt.Println("Success:", k)
>     }
>     v, ok := myInt.(float64)
>     if ok {
>         fmt.Println(v)
>     } else {
>         fmt.Println("Failed without panicking!")
>     }
>```

首先，声明```myInt```变量，该变量具有动态类型```int```和值```123```。然后，您使用类型断言两次来测试myint变量的接口—一次用于```int```，一次用于```float64```。

由于```myInt```变量不包含```float64```值，因此```myInt.(float64)```类型断言将失败，除非正确处理。幸运的是，在这种情况下，正确使用```ok```变量将使程序免于恐慌。

```assertion.go```程序的第二部分显示在以下Go代码中：

>```go
>     i := myInt.(int)
>     fmt.Println("No cheking:", i)
>     j := myInt.(bool)
>     fmt.Println(j)
> }
>```

这里有两种类型的断言。第一个类型断言是成功的，因此不会有任何问题。但是，让我们进一步回顾一下这个特定类型的断言。变量i的类型为```int```，其值为```123```，这是存储在```myInt```中的值。因此，由于```int```满足```myInt```接口，在这种情况下，因为```myInt```接口不需要函数来实现，所以```myInt.(int)```的值是一个int值。

但是，第二个类型断言```myInt.(bool)```将触发恐慌，因为```myInt```的基础值不是布尔值（bool）。因此，执行```assertion.go```将生成以下输出：

>```shell
> $ go run assertion.go
> Success: 123
> Failed without panicking!
> No cheking: 123
> panic: interface conversion: interface {} is int, not bool
>
> goroutine 1 [running]:
> main.main()
>       /Users/mtsouk/Desktop/masterGo/ch/ch7/code/assertion.go:25 +0x1d9
> exit status 2
>```

Go明确指出了恐慌的原因：```interface{} is int, not bool```。

一般来说，在处理接口时，也应该使用类型断言。您将在```useInterface.go```程序中看到更多类型断言，这些断言将在短时间内呈现。