- 前言

- 第一章：Go与操作系统

  - 1.1 本书结构

  - 1.2 Go的历史

  - 1.3 Why Go?

  - 1.4 Go的优势

    - 1.4.1 Go完美吗？
      - 1.4.1.1 什么是进程

    - 1.5 好用的Godoc

  - 1.6 Go的编译

  - 1.7 Go的可执行程序

  - 1.8 两条Go的基本准则

    - 1.8.1 无用的包不要导入
    - 1.8.2 "{}"的唯一位置

  - 1.9 下载你想用的包

  - 1.10 Unix的标准输入，标准输出，标准错误

  - 1.11 关于Go的打印输出

  - 1.12 使用标准输出

  - 1.13 得到用户输入

  - 1.14 关于 := 和 = 

    - 1.14.1 从标准输入读取
    - 1.14.2 处理命令行参数

  - 1.15 关于错误的输出

  - 1.16 写入日志文件

    - 1.16.1 logging的级别
    - 1.16.2 Unix log 设备文件
    - 1.16.3 Log 进程
    - 1.16.4 处理日志信息的示例程序
    - 关于 log.Fatal()
    - 关于 log.Panic()

  - Go的错误处理机制

    - error 的数据类型
    - 错误处理

  - 延展阅读

  - 练习

  - 本章小结

- 第二章 深入剖析Go的内部原理

  - 2.1 Go编译器
  - 2.2 Go的垃圾回收机制
    - 2.2.1 垃圾回收算法：Tricolor
    - 2.2.2 Go 垃圾回收器
    - 2.2.3 不安全的代码
    - 2.2.4 一些不安全的Go package
    - 2.2.5 不安全Go package 的一些代码示例
  - 2.3 Go调用C代码
    - 2.3.1 使用Go在同一文件中调用C代码
    - 2.3.2 使用Go跨文件调用C代码
    - 2.3.3 CGo的代码示例
  - 2.4 关于 Panic和Recover
  - 2.5 C调用Go代码
    - 2.5.1 CGo的代码示例
  - 2.6 defer 关键字
  - 2.7 单独使用Panic函数
  - 2.8 两个实用的UNIX小工具
    - 2.8.1 strace
    - 2.8.2 dtrace
  - 2.9 了解Go environment的函数
  - 2.10 Go与汇编
  - 2.11 Go的节点树
  - 2.12 了解更多构建信息
  - 2.13 关于Go代码的几点建议
  - 2.14 延展阅读
  - 2.15 练习
  - 2.16 本章小结

- 第三章 Go基本数据类型

  - 3.1 Go for循环
    - 3.1.1 for 循环
    - 3.1.2 while 循环
    - 3.1.3 关键字 range
    - 3.1.4 Go for 循环示例
  - 3.2 Go 数组
    - 3.2.1 多维数组
    - 3.2.2 Go数组的缺陷
  - 3.3 Go 切片
    - 3.3.1 切片基本操作
    - 3.3.2 切片的自动扩容
    - 3.3.3 字节切片
    - 3.3.4 copy() 函数解析
    - 3.3.5 多维切片
    - 3.3.6 使用切片的代码示例
    - 3.3.7 使用sort.slice()排序
  - 3.4 Go Map
    - 3.4.1 Map值为nil的坑
    - 3.4.2 何时该使用Map?
  - 3.5 Go 常量
    - 3.5.1 常量生成器：iota
  - 3.6 Go 指针
  - 3.7 时间与日期的处理技巧
    - 3.7.1 时间处理
    - 3.7.2 解析时间
    - 3.7.3 日期处理
    - 3.7.4 解析日期
    - 3.7.5 格式化时间与日期
  - 3.8 延展阅读
  - 3.9 练习
  - 3.10 本章小结

- 第四章 组合类型的使用

  - 4.1 关于组合类型
  - 4.2 结构体
    - 4.2.1 结构体指针
    - 4.2.2 new 关键字
  - 4.3 元组
  - 4.4 正则表达式与模式匹配
    - 4.4.1 理论知识
    - 4.4.2 简单的正则表达式示例
    - 4.4.3 高级的正则表达式示例
    - 4.4.4 正则匹配IPv4地址
  - 4.5 字符串
    - 4.5.1 rune是什么？
    - 4.5.2 关于Unicode的包
    - 4.5.3 关于字符串处理的包
  - 4.6 switch语句
  - 4.7 计算Pi的精确值
  - 4.8 实现简单的K-V存储
  - 4.9 延展阅读
  - 4.10 练习
  - 4.11 本章小结

- 第五章 数据结构的Go描述

  - 5.1 图及其节点

  - 5.2 算法复杂度简介

  - 5.3 二叉树

    - 5.3.1 Go实现二叉树
    - 5.3.2 二叉树的优势

  - 5.4 哈希表

    5.4.1 Go实现哈希表

    5.4.2 lookup函数实现

    5.4.3 哈希表的优势

  - 5.5 链表

    5.5.1 Go 实现链表

    5.5.2 链表的优势

  - 5.6 双向链表

    - 5.6.1 Go实现双向链表
    - 5.6.2 双向链表的优势

  - 5.7 队列

    - 5.7.1 Go实现队列

  - 5.8 栈

    - 5.8.1 Go实现栈

  - 5.9 Go标准库 container

    - 5.9.1 container/heap的使用
    - 5.9.2 container/list的使用
    - 5.9.3 container/ring的使用

  - 5.10 随机数
    - 5.10.1 随机字符串
  - 5.11 延展阅读
  - 5.12 练习
  - 5.13 本章小结

- 第六章 Go package中不为人知的知识

  - 6.1 关于Go packages
  - 6.2 Go函数
    - 6.2.1 匿名函数
    - 6.2.2 多返回值的函数
    - 6.2.3 可命名的函数返回值
    - 6.2.4 参数为指针的函数
    - 6.2.5 返回值为指针的函数
    - 6.2.6 闭包
    - 6.2.7 函数作为参数
  - 6.3 设计你的Go packages
    - 6.3.1 编译一个Go package
    - 6.3.2 私有变量和函数
    - 6.3.3 init() 函数
  - 6.4 阅读标准库代码
    - 6.4.1 探索net/url代码包
    - 6.4.2 探索log/syslog代码
  - 6.5 关于创建优雅的Go package的建议
  - 6.6 系统调用的包
    - 6.6.1 fmt.Println()的工作原理
  - 6.7 Text和HTML的模板
    - 6.7.1 生成text输出
    - 6.7.2 生成HTML输出
    - 6.7.3 基本SQLite3命令
  - 6.8 延展阅读
  - 6.9 练习
  - 6.10 本章小结

- 第七章 反射和接口

  - 7.1 类型方法
  - 7.2 Go的接口
  - 7.3 类型断言
  - 7.4 设计接口
    - 7.4.1  接口的使用
    - 7.4.2 switch用于类型判断
  - 7.5 反射
    - 7.5.1 使用反射的简单示例
    - 7.5.2 反射进阶
    - 7.5.3 反射的三个缺点
  - 7.6 Go的OOP思想
  - 7.7 延展阅读
  - 7.8 练习
  - 7.9 本章小结